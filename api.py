Xfrom flask import Flask, request, jsonify
from flask_cors import CORS
from openai import OpenAI
import os
import json
import base64
import zipfile
from fpdf import FPDF
from docx import Document
import requests

app = Flask(__name__)
CORS(app)

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
USAGE_FILE = "usage_log.json"

# Usage Limiting

def load_usage():
    if not os.path.exists(USAGE_FILE):
        return {}
    with open(USAGE_FILE, 'r') as f:
        return json.load(f)

def save_usage(data):
    with open(USAGE_FILE, 'w') as f:
        json.dump(data, f, indent=2)

def can_use(email):
    usage = load_usage()
    return usage.get(email, 0) < 5

def record_use(email):
    usage = load_usage()
    usage[email] = usage.get(email, 0) + 1
    save_usage(usage)

@app.route("/query", methods=["POST"])
def handle_query():
    data = request.get_json()

    name = data.get("full_name")
    email = data.get("email")
    query = data.get("query")

    try:
        job_code = int(data.get("job_code", 9999))
    except (ValueError, TypeError):
        job_code = 9999

    discipline = data.get("discipline", "").lower().replace(" ", "_")
    requires_action_sheet = bool(data.get("requires_action_sheet", False))
    source_context = str(data.get("source_context", ""))
    supervisor_email = data.get("supervisor_email")
    supervisor_name = data.get("supervisor_name")
    hr_email = data.get("hr_email")

    if not all([name, email, query]):
        return jsonify({"status": "error", "message": "Missing required fields"}), 400

    if not can_use(email):
        return jsonify({"status": "error", "message": "limit_reached"}), 403

    if 1000 <= job_code < 2000:
        role_type = "executive"
    elif 2000 <= job_code < 3000:
        role_type = "hr"
    elif 3000 <= job_code < 4000:
        role_type = "supervisor"
    elif 4000 <= job_code < 5000:
        role_type = "staff"
    else:
        role_type = "general"

    prompt = f"""
{source_context}

Please respond in structured JSON.
"""

    if requires_action_sheet:
        prompt += """
Include:
1. enquirer_reply — for the staff who raised the issue
2. action_sheet — a clear, numbered list for management or compliance
"""
    else:
        prompt += """
Include:
1. enquirer_reply — for the person raising the question
"""

    prompt += f"""

Query:
{query}
"""

    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}]
        )
        answer = response.choices[0].message.content
    except Exception as e:
        return jsonify({"status": "error", "message": f"OpenAI error: {str(e)}"}), 500

    full_text = f"Query from {name} ({email}):\n\n{query}\n\n---\n\nAI Response:\n{answer}\n\n---\n\nGenerated by AIVS | Role: {role_type}"

    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.multi_cell(0, 10, full_text)
    pdf_file = "response.pdf"
    pdf.output(pdf_file)

    doc = Document()
    doc.add_paragraph(full_text)
    docx_file = "response.docx"
    doc.save(docx_file)

    zip_file = "response.zip"
    with zipfile.ZipFile(zip_file, 'w') as zipf:
        zipf.write(pdf_file)
        zipf.write(docx_file)

    recipients = [email]
    if requires_action_sheet:
        if supervisor_email:
            recipients.append(supervisor_email)
        if hr_email:
            recipients.append(hr_email)

    try:
        with open(zip_file, "rb") as f:
            zip_encoded = base64.b64encode(f.read()).decode()

        for recipient in recipients:
            postmark_payload = {
                "From": os.getenv("POSTMARK_FROM_EMAIL"),
                "To": recipient,
                "Subject": "Your AI Response",
                "TextBody": "Please find your AI-generated response attached.",
                "Attachments": [
                    {
                        "Name": "response.zip",
                        "Content": zip_encoded,
                        "ContentType": "application/zip"
                    }
                ]
            }

            r = requests.post(
                "https://api.postmarkapp.com/email",
                headers={
                    "X-Postmark-Server-Token": os.getenv("POSTMARK_API_KEY"),
                    "Content-Type": "application/json"
                },
                json=postmark_payload
            )

            if r.status_code != 200:
                raise Exception(f"Postmark error: {r.status_code} - {r.text}")

    except Exception as e:
        return jsonify({"status": "error", "message": f"Postmark error: {str(e)}"}), 500

    record_use(email)
    return jsonify({"status": "success", "message": "Response emailed successfully."})
